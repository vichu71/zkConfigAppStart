package cestel.sercom.web.util;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.validation.Schema;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import cestel.sercom.web.vm.ResourceVm;
import lombok.extern.slf4j.Slf4j;


/**
 *
 * @author Administrador
 */
@Slf4j
public class DOMUtils {

    /** Objeto Logger para esta clase. Todas las trazas Log4j se configuran en
    * el archivo /conf/log4j.xml del AppServer. */
   
    /** Instancia de mi propio Error Handler. */ 
    transient static MyErrHandler errHandler = new MyErrHandler( log);
    
    /** Se oculta el CTOR de la clase para que no sea "instanciable" ya que se
     trata de un "Facade" con diferentes metodos utilitarios para el parsing XML.
     */
    private DOMUtils() {
    }

    /** Este metodo se utiliza para obtener el modelo DOM de un Documento XML.
     * Devuelve el RootElement de dicho documento XML, ya que es alli donde 
     * arrancara cualquier parseo posterior que se haga de los datos XML. <br>
     * Se utiliza principalmente para obtener la representacion DOM de los 
     * Archivos XML que describen entidades del Core, como por ejemplo un 
     * Device, un Plugin, o un Resource. <br>
     * @param File: es el archivo de disco que contiene el Documento XMl a 
     * parsear (del cual se desea obtener el modelo DOM).
     * @param Xsd: es un objeto Schema (opcional) que permite agregar validacion 
     * al proceso de parsing del Documento XML.
     * 
     * */
    public static Document getXmlFileRoot( File xmlFile, Schema Xsd)
    {
        try {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            
            String esl = "http://apache.org/xml/properties/schema/external-schemaLocation";
            Object val = "http://www.w3.org/2001/XMLSchema http://www.w3.org/2001/XMLSchema.xsd";
            dbf.setAttribute( esl, val);
            
            if(Xsd!=null)
              dbf.setSchema( Xsd);
            DocumentBuilder builder = dbf.newDocumentBuilder();
            builder.setErrorHandler( errHandler);
            errHandler.setXmlDocLabel( xmlFile.getName());
            Document document = builder.parse( xmlFile );
            return document;
           // return document.getDocumentElement();
          } catch (SAXParseException spe) {
            // Error generated by the parser
            log.error("DOMUtils: Parsing error"
            					+ ", line " + spe.getLineNumber()
            					+ ", uri " + spe.getSystemId());
            log.error("          " + spe.getMessage() );

            // Use the contained exception, if any
            Exception  x = spe;
            if (spe.getException() != null)
              x = spe.getException();
            x.printStackTrace();

          } catch (SAXException sxe) {
            // Error generated during parsing
            log.error("DOMUtils: SAXException -> " + sxe.getMessage());
            Exception  x = sxe;
            if (sxe.getException() != null)
              x = sxe.getException();
            x.printStackTrace();

          } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            log.error("DOMUtils: ParserConfigurationException -> " + pce.getMessage());
            pce.printStackTrace();
          } catch (IOException ioe) {
            // I/O error
            log.error("DOMUtils: IOException -> " + ioe.getMessage());
            ioe.printStackTrace();
          }
        return null;
    }
    
    /** Este metodo es identico al anterior, pero devuelve el Root Element
     * de un Documento Xml en formato String. <br>
     * Se utiliza principalmente en el parseo de los ConfigMsg.*/
    public static Element getXmlStringRoot( String xmlStr)
    {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputSource is = new InputSource(new StringReader(xmlStr));
            Document document = builder.parse( is );
            
            return document.getDocumentElement();
          } catch (SAXParseException spe) {
            // Error generated by the parser
            log.error("DOMUtils: Parsing error"
            					+ ", line " + spe.getLineNumber()
            					+ ", uri " + spe.getSystemId());
            log.error("          " + spe.getMessage() );

            // Use the contained exception, if any
            Exception  x = spe;
            if (spe.getException() != null)
              x = spe.getException();
            x.printStackTrace();

          } catch (SAXException sxe) {
            // Error generated during parsing
            log.error("DOMUtils: SAXException -> " + sxe.getMessage());
            Exception  x = sxe;
            if (sxe.getException() != null)
              x = sxe.getException();
            x.printStackTrace();

          } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            log.error("DOMUtils: ParserConfigurationException -> " + pce.getMessage());
            pce.printStackTrace();
          } catch (IOException ioe) {
            // I/O error
            log.error("DOMUtils: IOException -> " + ioe.getMessage());
            ioe.printStackTrace();
          }
        return null;
    }

    /** Este metodo utilitario oculta levemente la complejidad del arbol
     DOM, al obtener el Texto de un determinado sub-elemento, si existe.<br>  */
    public static String getChildNodeText( Element XmlNode, String SubNodeName)
    {
        String retstr="";
        NodeList nodes = XmlNode.getElementsByTagName( SubNodeName);
        if( nodes.getLength()>0 )
        {    
            Node sn = nodes.item(0).getFirstChild();
            if(sn.getNodeType() == Node.TEXT_NODE)
                retstr = sn.getNodeValue();
        }    
        return retstr;
    }

    /** Este metodo utilitario oculta levemente la complejidad del arbol
     DOM, al obtener los Textos de un conjunto de sub-elementos.<br>  */
    public static String[] getChildrenText( Element XmlNode, String SubNodesName)
    {
        ArrayList<String> retval = new ArrayList<String>();
        NodeList nodes = XmlNode.getElementsByTagName( SubNodesName);
        for( int i=0; i<nodes.getLength(); i++ )
        {    
            Node sn = nodes.item(i).getFirstChild();
            if(sn.getNodeType() == Node.TEXT_NODE)
                retval.add( sn.getNodeValue()); 
        }    
        return retval.toArray( new String[0]);
    }
    
    /** Metodo utilitario para facilitar el parseo de los atributos XML cuyo
     contenido representa un Booleano.*/
    public static boolean parseBoolAttribute( Element XmlNode, String AttribName, boolean Default)
    {
        String  strval = XmlNode.getAttribute( AttribName);
        return parseBool( strval, Default);
    }

    /** Metodo utilitario para facilitar el parseo de los strings cuyo
     contenido representa un Booleano.*/
    public static boolean parseBool( String StrBoolValue, boolean Default)
    {
        boolean retval = Default;
        if(StrBoolValue.length()>0)
        {    
            // Segun sea su valor por defecto detecto solo el contrario
            if(Default)
            {
                if( (StrBoolValue.compareTo("false")==0) || (StrBoolValue.compareTo("0")==0) )
                    retval = false;
            }
            else
            {
                if( (StrBoolValue.compareTo("true")==0) || (StrBoolValue.compareTo("1")==0) )
                    retval = true;
            }
        }    
        return retval;
    }

    
    /** Defino una clase interna para tratamiento de los errores de Parsing y
     * Validacion de documentos XML. */
    private static class MyErrHandler implements ErrorHandler
    {
      
      transient Logger log = null;
      
      private String xmlDocLabel = "";
      
      /** En el CTOR le entrego un objeto Logger, para que pueda soltar trazas
       * de los problemas de parsing y validacion XML. */
      public MyErrHandler(Logger Log)
      {
        this.log = Log;
      }
      
      public void warning(SAXParseException exception) throws SAXException
      {
        log.warn("DOMUtils: ParserWarning in " + xmlDocLabel + " at line " + 
                 exception.getLineNumber() + " -> " + exception.getMessage());
      }

      public void error(SAXParseException exception) throws SAXException
      {
        log.warn("DOMUtils: ParserError in " + xmlDocLabel + " line " + 
                 exception.getLineNumber() + " -> " + exception.getMessage());
      }

      public void fatalError(SAXParseException exception) throws SAXException
      {
        log.warn("DOMUtils: ParserFatalError in " + xmlDocLabel + " line " + 
                 exception.getLineNumber() + " -> " + exception.getMessage());
      }
      
      /** Este metodo permite configurar una etiqueta que saldra en las trazas.
       * Esta pensada para guardar el nombre del Documento o Archivo XML que se
       * va a parsear, de forma que si esta clase maneja un error deje una traza
       * clara de su ubicacion. */
      public void setXmlDocLabel( String aLabel){
        xmlDocLabel = aLabel;
      }
      
    }
    
}
